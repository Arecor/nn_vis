#version 430

struct SamplePoint
{
    vec4 pos;
};

struct DensityGrid
{
    int overall_density;
    int density_0;
    int density_1;
    int density_2;
    int density_3;
    int density_4;
    int density_5;
    int density_6;
    int density_7;
    int density_8;
    int density_9;
    int fill;
};

struct EdgeData
{
    float samples;
    float start_edge_count;
    float end_edge_count;
    float importance;
    float start_importance_length;
    float end_importance_length;
    float start_importance;
    float end_importance;
    float start_importance_0;
    float start_importance_1;
    float start_importance_2;
    float start_importance_3;
    float start_importance_4;
    float start_importance_5;
    float start_importance_6;
    float start_importance_7;
    float start_importance_8;
    float start_importance_9;
    float end_importance_0;
    float end_importance_1;
    float end_importance_2;
    float end_importance_3;
    float end_importance_4;
    float end_importance_5;
    float end_importance_6;
    float end_importance_7;
    float end_importance_8;
    float end_importance_9;
};

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std140, binding = 0) restrict readonly buffer sample_input
{
    SamplePoint input_sample[];
};

layout(std140, binding = 1) writeonly buffer sample_output
{
    SamplePoint output_sample[];
};

layout(std140, binding = 2) restrict readonly buffer edge_data
{
    EdgeData edge[];
};

layout(std140, binding = 3) restrict readonly buffer density_grid
{
    DensityGrid density[];
};

uniform int work_group_offset;
uniform int max_sample_points;
uniform int slice_count;
uniform int slice_size;
uniform int current_buffer;

uniform float advect_strength;
uniform float importance_similarity = 0.5;

uniform ivec3 grid_cell_count;
uniform vec3 grid_cell_size;
uniform vec3 grid_bounding_min;

EdgeData current_edge;
float importance[10];
float overall_importance;

ivec3 gridIndex(vec3 position)
{
    return ivec3(int(floor((position.x - grid_bounding_min.x)/grid_cell_size.x)),
    int(floor((position.y - grid_bounding_min.y)/grid_cell_size.y)),
    int(floor((position.z - grid_bounding_min.z)/grid_cell_size.z)));
}

vec3 gridDirection(ivec3 index, vec3 position)
{
    float x = sign((position.x - grid_bounding_min.x)/grid_cell_size.x - (float(index.x)) - 0.5);
    if (x == 0.0) x = 1.0;
    float y = sign((position.y - grid_bounding_min.y)/grid_cell_size.x - (float(index.y)) - 0.5);
    if (y == 0.0) y = 1.0;
    float z = sign((position.z - grid_bounding_min.z)/grid_cell_size.x - (float(index.z)) - 0.5);
    if (z == 0.0) z = 1.0;
    return vec3(x, y, z);
}

vec4 read(highp uint index)
{
    return input_sample[index].pos;
}

EdgeData readEdge(highp uint index)
{
    return edge[int(floor(index/max_sample_points))];
}

void write(highp uint index, vec4 pos)
{
    output_sample[index].pos = pos;
}

DensityGrid readGridIndex(ivec3 index)
{
    highp int original_index = index.x + index.y * grid_cell_count.x + index.z * grid_cell_count.x * grid_cell_count.y;
    return density[original_index - current_buffer * slice_count * slice_size];
}

highp float getGradientAxis(DensityGrid density_from, DensityGrid density_to)
{
    highp float drive_towards = 0.0;
    highp float drive_from = 0.0;

    float towards_density_overall = sqrt(density_to.density_0 * density_to.density_0
    + density_to.density_1 * density_to.density_1
    + density_to.density_2 * density_to.density_2
    + density_to.density_3 * density_to.density_3
    + density_to.density_4 * density_to.density_4
    + density_to.density_5 * density_to.density_5
    + density_to.density_6 * density_to.density_6
    + density_to.density_7 * density_to.density_7
    + density_to.density_8 * density_to.density_8
    + density_to.density_9 * density_to.density_9);
    float from_density_overall = sqrt(density_from.density_0 * density_from.density_0
    + density_from.density_1 * density_from.density_1
    + density_from.density_2 * density_from.density_2
    + density_from.density_3 * density_from.density_3
    + density_from.density_4 * density_from.density_4
    + density_from.density_5 * density_from.density_5
    + density_from.density_6 * density_from.density_6
    + density_from.density_7 * density_from.density_7
    + density_from.density_8 * density_from.density_8
    + density_from.density_9 * density_from.density_9);


    drive_towards += importance[0] * (density_to.density_0/towards_density_overall);
    drive_towards += importance[1] * (density_to.density_1/towards_density_overall);
    drive_towards += importance[2] * (density_to.density_2/towards_density_overall);
    drive_towards += importance[3] * (density_to.density_3/towards_density_overall);
    drive_towards += importance[4] * (density_to.density_4/towards_density_overall);
    drive_towards += importance[5] * (density_to.density_5/towards_density_overall);
    drive_towards += importance[6] * (density_to.density_6/towards_density_overall);
    drive_towards += importance[7] * (density_to.density_7/towards_density_overall);
    drive_towards += importance[8] * (density_to.density_8/towards_density_overall);
    drive_towards += importance[9] * (density_to.density_9/towards_density_overall);

    drive_from += importance[0] * (density_from.density_0/from_density_overall);
    drive_from += importance[1] * (density_from.density_1/from_density_overall);
    drive_from += importance[2] * (density_from.density_2/from_density_overall);
    drive_from += importance[3] * (density_from.density_3/from_density_overall);
    drive_from += importance[4] * (density_from.density_4/from_density_overall);
    drive_from += importance[5] * (density_from.density_5/from_density_overall);
    drive_from += importance[6] * (density_from.density_6/from_density_overall);
    drive_from += importance[7] * (density_from.density_7/from_density_overall);
    drive_from += importance[8] * (density_from.density_8/from_density_overall);
    drive_from += importance[9] * (density_from.density_9/from_density_overall);

    return towards_density_overall * (drive_towards - importance_similarity) - from_density_overall * (drive_from - importance_similarity);
}

vec4 getGradient(ivec3 grid_index, vec3 grid_direction)
{
    DensityGrid current_density = readGridIndex(grid_index);
    DensityGrid x_diff_density = readGridIndex(ivec3(grid_index.x + int(grid_direction.x), grid_index.y, grid_index.z));
    DensityGrid y_diff_density = readGridIndex(ivec3(grid_index.x, grid_index.y + int(grid_direction.y), grid_index.z));
    DensityGrid z_diff_density = readGridIndex(ivec3(grid_index.x, grid_index.y, grid_index.z + int(grid_direction.z)));

    float gradient_x = getGradientAxis(current_density, x_diff_density) * grid_direction.x;
    float gradient_y = getGradientAxis(current_density, y_diff_density) * grid_direction.y;
    float gradient_z = getGradientAxis(current_density, z_diff_density) * grid_direction.z;
    vec3 calc_gradient = vec3(gradient_x, gradient_y, gradient_z);
    float strength = length(calc_gradient);

    strength = max(strength, 0.00001);
    calc_gradient = calc_gradient / strength;
    return vec4(calc_gradient, strength);
}

void main() {
    highp uint index = gl_WorkGroupID.x + work_group_offset;

    vec4 sample_data = read(index);
    if (sample_data.w == 1.0) {
        current_edge = readEdge(index);
        float t = mod(index, max_sample_points)/current_edge.samples;
        importance[0] = (1.0 - t) * current_edge.start_importance_0/current_edge.start_importance_length + t * current_edge.end_importance_0/current_edge.end_importance_length;
        importance[1] = (1.0 - t) * current_edge.start_importance_1/current_edge.start_importance_length + t * current_edge.end_importance_1/current_edge.end_importance_length;
        importance[2] = (1.0 - t) * current_edge.start_importance_2/current_edge.start_importance_length + t * current_edge.end_importance_2/current_edge.end_importance_length;
        importance[3] = (1.0 - t) * current_edge.start_importance_3/current_edge.start_importance_length + t * current_edge.end_importance_3/current_edge.end_importance_length;
        importance[4] = (1.0 - t) * current_edge.start_importance_4/current_edge.start_importance_length + t * current_edge.end_importance_4/current_edge.end_importance_length;
        importance[5] = (1.0 - t) * current_edge.start_importance_5/current_edge.start_importance_length + t * current_edge.end_importance_5/current_edge.end_importance_length;
        importance[6] = (1.0 - t) * current_edge.start_importance_6/current_edge.start_importance_length + t * current_edge.end_importance_6/current_edge.end_importance_length;
        importance[7] = (1.0 - t) * current_edge.start_importance_7/current_edge.start_importance_length + t * current_edge.end_importance_7/current_edge.end_importance_length;
        importance[8] = (1.0 - t) * current_edge.start_importance_8/current_edge.start_importance_length + t * current_edge.end_importance_8/current_edge.end_importance_length;
        importance[9] = (1.0 - t) * current_edge.start_importance_9/current_edge.start_importance_length + t * current_edge.end_importance_9/current_edge.end_importance_length;
        overall_importance = (1.0 - t) * current_edge.start_importance + t * current_edge.end_importance;

        ivec3 grid_index = gridIndex(sample_data.xyz);
        if (grid_index.z >= current_buffer * slice_count && grid_index.z < (current_buffer + 1) * slice_count)
        {
            vec3 gradient_direction = vec3(0.0, 0.0, 0.0);
            highp float overall_strength = 0.0;

            vec4 gradient = getGradient(grid_index, gridDirection(grid_index, sample_data.xyz));
            gradient_direction = gradient.xyz;
            overall_strength = gradient.w;

            if (overall_strength >= 1.0) {
                sample_data = vec4(sample_data.x + gradient_direction.x * advect_strength, sample_data.y + gradient_direction.y * advect_strength, sample_data.z + gradient_direction.z * advect_strength, sample_data.w);
            }
            write(index, sample_data);
        }
    } else {
        write(index, sample_data);
    }
}