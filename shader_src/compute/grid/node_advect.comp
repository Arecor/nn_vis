#version 430

struct Node
{
    vec4 pos;
    float importance_0;
    float importance_1;
    float importance_2;
    float importance_3;
    float importance_4;
    float importance_5;
    float importance_6;
    float importance_7;
    float importance_8;
    float importance_9;
    float overall_importance;
    float importance_length;
};

struct DensityGrid
{
    int overall_density;
    int density_0;
    int density_1;
    int density_2;
    int density_3;
    int density_4;
    int density_5;
    int density_6;
    int density_7;
    int density_8;
    int density_9;
    int fill;
};

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(std140, binding = 0) restrict readonly buffer node_input
{
    Node input_node[];
};
layout(std140, binding = 1) writeonly buffer node_output
{
    Node output_node[];
};
layout(std140, binding = 2) restrict readonly buffer density_grid
{
    DensityGrid density[];
};

uniform int work_group_offset;
uniform float advect_strength;

uniform ivec3 grid_cell_count;
uniform vec3 grid_cell_size;
uniform vec3 grid_bounding_min;
uniform vec3 grid_bounding_max;

const float sqrt_ten = 3.162277660168379;

ivec3 gridIndex(vec3 position)
{
    return ivec3(int(floor((position.x - grid_bounding_min.x)/grid_cell_size.x)),
    int(floor((position.y - grid_bounding_min.y)/grid_cell_size.y)),
    0);
}

vec3 gridDirection(ivec3 index, vec3 position)
{
    float x = sign((position.x - grid_bounding_min.x)/grid_cell_size.x - (float(index.x)) - 0.5);
    if (x == 0.0) x = 1.0;
    float y = sign((position.y - grid_bounding_min.y)/grid_cell_size.x - (float(index.y)) - 0.5);
    if (y == 0.0) y = 1.0;
    float z = sign((position.z - grid_bounding_min.z)/grid_cell_size.x - (float(index.z)) - 0.5);
    if (z == 0.0) z = 1.0;
    return vec3(x, y, z);
}

Node read(highp uint index)
{
    return input_node[index];
}

void write(highp uint index, vec4 pos)
{
    output_node[index].pos = pos;
}

DensityGrid readGridIndex(ivec3 index)
{
    return density[index.x + index.y * grid_cell_count.x];
}

highp float getGradientAxis(DensityGrid density_from, DensityGrid density_to, Node node)
{
    highp float drive = 0.0;
    drive += (node.importance_0/node.importance_length) * (density_to.density_0 - density_from.density_0);
    drive += (node.importance_1/node.importance_length) * (density_to.density_1 - density_from.density_1);
    drive += (node.importance_2/node.importance_length) * (density_to.density_2 - density_from.density_2);
    drive += (node.importance_3/node.importance_length) * (density_to.density_3 - density_from.density_3);
    drive += (node.importance_4/node.importance_length) * (density_to.density_4 - density_from.density_4);
    drive += (node.importance_5/node.importance_length) * (density_to.density_5 - density_from.density_5);
    drive += (node.importance_6/node.importance_length) * (density_to.density_6 - density_from.density_6);
    drive += (node.importance_7/node.importance_length) * (density_to.density_7 - density_from.density_7);
    drive += (node.importance_8/node.importance_length) * (density_to.density_8 - density_from.density_8);
    drive += (node.importance_9/node.importance_length) * (density_to.density_9 - density_from.density_9);
    drive -= 1.0 * (density_to.overall_density - density_from.overall_density) * node.overall_importance;
    return drive;
}

vec4 getGradient(ivec3 grid_index, vec3 grid_direction, Node node)
{
    DensityGrid current_density = readGridIndex(grid_index);
    DensityGrid x_diff_density = readGridIndex(ivec3(grid_index.x + int(grid_direction.x), grid_index.y, grid_index.z));
    DensityGrid y_diff_density = readGridIndex(ivec3(grid_index.x, grid_index.y + int(grid_direction.y), grid_index.z));

    float gradient_x = getGradientAxis(current_density, x_diff_density, node) * grid_direction.x;
    float gradient_y = getGradientAxis(current_density, y_diff_density, node) * grid_direction.y;
    vec3 calc_gradient = vec3(gradient_x, gradient_y, 0.0);
    float strength = length(calc_gradient);

    strength = max(strength, 0.00001);
    calc_gradient = calc_gradient / strength;
    return vec4(calc_gradient, strength);
}

void main() {
    highp uint index = gl_WorkGroupID.x + work_group_offset;

    Node node = read(index);
    vec4 node_data = node.pos;
    if (node_data.w == 1.0) {
        ivec3 grid_index = gridIndex(node_data.xyz);
        float importance_vec_length = 0.0;
        importance_vec_length += node.importance_0 * node.importance_0;
        importance_vec_length += node.importance_1 * node.importance_1;
        importance_vec_length += node.importance_2 * node.importance_2;
        importance_vec_length += node.importance_3 * node.importance_3;
        importance_vec_length += node.importance_4 * node.importance_4;
        importance_vec_length += node.importance_5 * node.importance_5;
        importance_vec_length += node.importance_6 * node.importance_6;
        importance_vec_length += node.importance_7 * node.importance_7;
        importance_vec_length += node.importance_8 * node.importance_8;
        importance_vec_length += node.importance_9 * node.importance_9;


        vec3 gradient_direction = vec3(0.0, 0.0, 0.0);
        highp float overall_strength = 0.0;

        vec4 gradient = getGradient(grid_index, gridDirection(grid_index, node_data.xyz), node);
        gradient_direction = gradient.xyz;
        overall_strength = gradient.w;

        if (overall_strength >= 0.1) {
            node_data = vec4(node_data.x + gradient_direction.x * advect_strength * 0.2, node_data.y + gradient_direction.y * advect_strength * 0.2, node_data.z, node_data.w);
            float bounding_offset = abs(advect_strength) * 0.2;
            if(node_data.x < grid_bounding_min.x + bounding_offset + 2.0 * grid_cell_size.x) node_data = vec4(grid_bounding_min.x + bounding_offset + 2.0 * grid_cell_size.x, node_data.y,  node_data.z,  node_data.w);
            if(node_data.x > grid_bounding_max.x - bounding_offset - 2.0 * grid_cell_size.x) node_data = vec4(grid_bounding_max.x - bounding_offset - 2.0 * grid_cell_size.x, node_data.y,  node_data.z,  node_data.w);
            if(node_data.y < grid_bounding_min.y + bounding_offset + 2.0 * grid_cell_size.y) node_data = vec4(node_data.x, grid_bounding_min.y + bounding_offset + 2.0 * grid_cell_size.y, node_data.z,  node_data.w);
            if(node_data.y > grid_bounding_max.y - bounding_offset - 2.0 * grid_cell_size.y) node_data = vec4(node_data.x, grid_bounding_max.y - bounding_offset - 2.0 * grid_cell_size.y, node_data.z,  node_data.w);
        }
        write(index, node_data);
    } else {
        write(index, node_data);
    }
}